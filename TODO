TODO:

URGENT:
- Verify new data with the newly created LM model
- Implement C++ code from LM python model
- Verify C++ code compute capability on the esp32
- Implement data_logger_sd onto device    DONE
- update sensor_test.cpp to collect data at SAMPLE_RATE_ACCEL_HZ 1000 DONE
- Assembl of the datalogger version of the sensor to take to Spain   DONE
- wrap up MAX1740 into an ifdef so that if not present no error DONE
- use on board LED heltec to displayy alarms for the data_logger_sd case only RE-THOUGHT
- repeater assembly DONE

THIS WEEK:
- collect physical data on the device (ask Juan chainsaw again) DONE
- implement and test the clasifier with google lab (by Thursday) DONE


WHILE IN SPAIN:
- extraction of data + elaboration of classifier URGENT
- TEST clasifier on new PCB module && distance test URGENT
- send FINALIZED 40 pcb'S for manufacturing (find out where to send them, Spain?)
- Meshtastic code Moritz
- Data logging with chainsaw ONLY horizontal DONE

ON ARRIVAL TO ECUADOR (until 15th May)
- sensor casing + batt done
- repeater board NO WOOD! but plastic, maybe pvc?
- repeaters ready to install by Friday (request $800 for installation expenses)
- seal repeaters completely from moist
- Router code + hardware test full system
- writing training documents for staff

NICE TO HAVE: 
- Update README file

# TODO ‚Äì Real-Time Classifier Roadmap (Next Steps)

## üõ†Ô∏è Current State

- **File**: `real_classifier.cpp`
- **Purpose**: Test wake-up cycles, I2C initialization, MPU6050 readings, MAX1704x integration, and basic LittleFS logging.
- **Status**: Functional, deep sleep works, LittleFS works, MAX1704x optional/missing, classification placeholder logic active.

## üîç Missing Features (to be added next)

| Requirement                          | Status          | Notes |
|--------------------------------------|-----------------|-------|
| Buffering ~12 seconds of data        | ‚ùå Not present   | Add RAM buffer for accelerometer X/Y/Z |
| Sampling at fixed rate (e.g., 333Hz) | ‚ùå Not implemented | Use microsecond pacing loop |
| Store full buffer before processing  | ‚ùå Only 1 sample | Save all readings to LittleFS or use for live classification |
| In-memory FFT/wavelet classification | üîú To be added   | Use existing Python logic as reference |

## ‚úÖ Near-Term Goals

1. Scaffold `collectBlockOfData()` to fill X/Y/Z buffers over ~12 seconds.
2. Store the buffered result in LittleFS (`/raw_session_<n>.csv`).
3. (Optional) Start porting energy band / FFT logic from Python ‚Üí C++.
4. Replace placeholder classification with buffered classification.

## üß™ Testing Plan

- [ ] Validate 12s buffered acquisition at 333Hz.
- [ ] Log CSV file to LittleFS from RAM.
- [ ] Confirm file integrity post-reset via serial dump.
- [ ] Leave room for enabling classification on buffered data.

---

üìÖ _Next coding session: Start by implementing `collectBlockOfData()` and buffering architecture._

